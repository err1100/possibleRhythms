
#Hard coded note values, where 1 is a quarter note
values = [.25,.5,.75,1,1.5,2,3,4]
#T/F values indicating whether a note is dotted
isDotted = [0,0,1,0,1,0,1,0]

#Note: level is just a debug argument that keeps track
#of the current recursion level
#Returns the number of possible rhythms that can fill the
#given number of beats
def numPossibleMeasure(toFill,level = 0):
    total = 0
    for i in range(len(values)):
        #If we can't fit this value in the remaining space,
        #then we're done
        if values[i] > toFill:
            break
        #If it fits exactly, then that's one possible rhythm
        elif values[i] == toFill:
            #Add two, not one, since this note could be a rest
            #See note below about dotting condition
            if not isDotted[i]:
                total += 2
            else: total += 1
        #If it's smaller, then put it in and recurse with the
        #remaining space
        else:
            tempPossible = numPossibleMeasure(toFill-values[i],level+1)
            if not isDotted[i]:
                tempPossible *= 2
            total += tempPossible
    return total

#Returns the number of possible n-measure phrases
#based on the number of possible one-measure rhythms
def numPossiblePhrase(numPossibleMeasure, phraseLength):
    return numPossibleMeasure**phraseLength

#Note about dotting condition:
#A quarter note followed by an eighth note is not equivalent to a dotted quarter note.
#But a quarter rest followed by an eigth rest is equivalen to a dotted quarter rest.
#Thus, we do not multiply by two for dotted notes.
#You might notice that a quarter rest followed by an eighth rest *is* equivalent to an eighth rest
#followed by a quarter rest, both of which are generated by this program. Well, it isn't perfect.

